//
//
//Does the species interaction affect species diversity?
// half compunds (odd i) are nutrious , while the rests are toxic (even i)
// given number of species sample random parameter values
// check wehther the mean value of toxicity affets switching rate vs diversity
// resources' max effects mus are 1 on average
// MEAN toxin effect can varies: toxicity follows beta distribtuion
// parameter values are generated by parm_generator.c
#include <stdio.h>
#include <math.h>
#include <time.h>
#include <stdlib.h>
#include <sys/stat.h>
#include "MT.h"
#include <unistd.h>

void ComDynamicas(int num, double delta);
void Gillespie(int num, double **beta, double **K, double **Y, int n);
void Trans_rate(double *transition, double *C, double *S, double ** beta, double **K, double **Y, double nu, int num, int state);
double Waiting_time(double *transition, int num);
double Uniform( void );
double rand_exp( double lambda );
int BD_process(double *transition, int num);
double *malloc_vector(int n);
void free_vector(double *a);
int *malloc_vector_int(int n);
void free_vector_int(int *a);
double **malloc_matrix(int nrow, int ncol);
void free_matrix(double **a, int nrow);

#define x_max 200 // largest supply
#define x_min 50 // minimum supply
#define x_mean 125// mean supply
#define alpha 0.1 // dilution rate
#define maxK 100 // maximum value of K
void ComDynamics(int num, double delta)
{
    /*
     Run community dynamics composed of N species and N compounds
     num: number of species
     delta: mean toxicity
     */
    //initialize parameters
    int type = 100;  // sampleing number for parameter values
    int n, i, j, k, l;
    double **beta; //matrix for species per capita effects on compounds
    beta=malloc_matrix(num, num); // beta[i,j] is effect of species i on compund j
    double **K; // amount of compound that gives harf-max effect on species
    K=malloc_matrix(num, num); //
    double **Y; // yeaild assumes either 1 or -1 so that each species always decreases amount of comopund
    Y=malloc_matrix(num, num);
    char path[256];
    char fname1[256];
    char fname2[256];
    init_genrand((unsigned)time(NULL));// seed
    //end initilization
    for (i=1;i<=type;i++)
    {
        printf("parameter set %d \n",i);
        sprintf(path, "./parameter%d", i);
        mkdir(path, 0777);
        chdir(path);

        // read cev file for parameter list beta and K
        FILE *fp1;
        sprintf(fname1,"Prameter_beta_set%d.csv",i);
        if ((fp1 = fopen(fname1,"r"))== NULL)
        {
            printf("unable to make result file. \n");
            exit(1);
        }
        fp1 = fopen(fname1,"r");
        //printf("growth or death \n");
        for (k=1; k<=num; k++)
        {
            for(l=1;l<=num;l++)
            {
                fscanf(fp1,"%lf,",&beta[k][l]);
                //printf("%.3f \n", beta[k][l]);
                if (beta[k][l]<0)
                {
                    Y[k][l]=-1.0;// so that beta/Y>0
                }
                else
                {
                    Y[k][l]=1.0;
                }
                
            }
        }
        fclose(fp1);
        
        FILE *fp2;
        sprintf(fname2,"Prameter_K_set%d.csv",i);
        if ((fp2 = fopen(fname2,"r"))== NULL)
        {
            printf("unable to make result file. \n");
            exit(1);
        }
        fp2 = fopen(fname2,"r");
        //printf("K values \n");
        for (k=1; k<=num; k++)
        {
            for(l=1;l<=num;l++)
            {
                fscanf(fp2,"%lf,",&(K[k][l]));
                //printf("%.3f \n", K[k][l]);
            }
        }
        fclose(fp2);
        for (n=-5; n<=3; n++)
        {
            //printf("===> switching rate is 10^%d \n", n);
            // run Gillespie algorithem
           
            Gillespie(num, beta, K, Y, n);
           
            
        }
        chdir("../");
    }
    free_matrix(beta, num);
    free_matrix(K, num);
    free_matrix(Y, num);
}

void Gillespie(int num, double **beta, double **K, double **Y, int n)
{
    // run Grispie algorithem and  save the dynamis
    double t; // time
    int i, j, event;
    int iterate = 100; // number of iteration given parameter sets
    int state;//
    double nu=pow(10, n);//environmental switching rate
    double waiting;//ã€€waiting time
    double tf=200.0;// end of simulation
    double *C;//compund
    C=malloc_vector(num);
    double *S; //species
    S=malloc_vector(num);
    double *transition; // transition rate vector
    transition=malloc_vector(num*4+1);//  increase/decrease of species and compound + environmental switching
    char dname[512];
    // set csv file
    FILE *fp3;
    sprintf(dname,"Dynamics_nu%d_last.csv", n);
    if ((fp3 = fopen(dname,"w"))== NULL)
    {
        printf("unable to make result file. \n");
        exit(1);
    }
    fp3=fopen(dname,"w");
    //label
    fprintf(fp3,"trial,");
    for(i=1;i<=num;i++)
    {
        fprintf(fp3,"C%d,",i);
    }
    for(i=1;i<=num;i++)
    {
        fprintf(fp3,"S%d,",i);
    }
    fprintf(fp3,"state");
    
    for(j=1; j<=iterate; j++)
    {
        t=0.0;//time initilize
        //initial conditions
        if (Uniform()<0.5)
        {
            state=1;
        }
        else
        {
            state=-1;
        }
        for(i=1;i<=num;i++)
        {
            C[i]=150.0;
            S[i]=10.0;
        }
        Trans_rate(transition,C, S, beta, K, Y, nu, num, state);
        //transition=Trans_rate(C, S, beta, K, Y, nu, num, state);
        waiting=Waiting_time(transition, num);
        //end setting initial condition
        while (t+waiting<=tf)
        {
            // update process
            event=BD_process(transition, num);// determine event
            if(event<=num)
            {
                // increase compounds amount
                C[event]+=1;
            }
            else if (event<=2*num)
            {
                // decrease compounds amount
                C[event-num]-=1;
            }
            else if (event<=3*num)
            {
                //increase species
                //printf("increase S\n");
                S[event-2*num]+=1;
            }
            else if(event<=4*num)
            {
                //decreasing species
                S[event-3*num]-=1;
            }
            else
            {
                // environmental switching
                state=-state;
            }
            t += waiting;
            //update transition vector
            Trans_rate(transition,C, S, beta, K, Y, nu, num, state);
            //transition=Trans_rate(C, S, beta, K, Y, nu, num, state);
            waiting=Waiting_time(transition, num);
        }//end while
        // last condition
        fprintf(fp3,"\n%d,",j);
        for(i=1;i<=num;i++)
        {
            fprintf(fp3,"%.0f,",C[i]);
        }
        for(i=1;i<=num;i++)
        {
            fprintf(fp3,"%.0f,",S[i]);
        }
        fprintf(fp3,"%d",state);
    }// end iteration loop
    fclose(fp3);
    //free vector
    free_vector(C);
    free_vector(S);
    free_vector(transition);
}

void Trans_rate(double *transition, double *C, double *S, double ** beta, double **K, double **Y, double nu, int num, int state)
{
    // update transiton rate vector
    double **growth_func;
    growth_func=malloc_matrix(num, num);
    double **effect_func;
    effect_func=malloc_matrix(num, num);
    int i,j;
    
    // growth and effect matrices
    for(i=1;i<=num; i++)
    {
        for (j=1; j<=num; j++)
        {
            growth_func[i][j] = C[j] / (C[j]+K[i][j]) * beta[i][j];
            effect_func[i][j] = growth_func[i][j]/Y[i][j];
            
        }
    }
    //transtion vector
    for (i=1; i<=num; i++)
    {
        if(i%2==1)
        {
            // resource supply
            if (state>0)
            {
                transition[i]=alpha*x_max; // abundant resource supply
            }
            else
            {
                transition[i]=alpha*x_min; // scarce resoruce supply
            }
        }
        else
        {
            // toxin supply
            transition[i]=alpha*x_mean; // mean toxin supply
        }
        
        transition[num+i]=alpha*C[i]; // decrease of compounds dilution
        transition[2*num+i]=0; // initilizing increase of species
        transition[3*num+i]=alpha; // per capita decrease of species by dilution
        for (j=1;j<=num;j++)
        {
            if (growth_func[i][j]<0)
            {
                // compound j is toxic to speices i
                transition[3*num+i]-=growth_func[i][j];
            }
            else
            {
                // compound j is nutrieous to speices i
                transition[2*num+i]+=growth_func[i][j];
            }
            transition[num+i]+=S[j]*effect_func[j][i]; // compound i consumec or absorbed by species j
        }
        transition[2*num+i]=S[i]*transition[2*num+i];
        transition[3*num+i]=S[i]*transition[3*num+i];
        //printf("species %d: growth rate %.6f and death rate %.3f \n", i, transition[2*num+i], transition[3*num+i]);
    }
    transition[4*num+1]=nu;
    free_matrix(growth_func, num);
    free_matrix(effect_func, num);
   
}

double Waiting_time(double *transition, int num)
{
    double rate_all;// sum of transiton rate
    rate_all=0.0;
    int i;
    for (i=1;i<=4*num+1;i++)
    {
        rate_all+=transition[i];
    }
    // calculate waiting time
    return rand_exp(rate_all);
}

int BD_process(double *transition, int num)
{
    // determine which BD process happen
    double rate_all=0.0;// sum of transiton rate
    double p=Uniform();// random value from 0 to 1
    double count=0.0;
    int i;
    for (i=1;i<=4*num+1;i++)
    {
        rate_all+=transition[i];
    }
    for (i=1;i<=4*num+1;i++)
    {
        count+=transition[i]/rate_all;// probability event i happens
        if (p<=count)
        {
            //printf("Event %d \n", i);
            return i;
        }
    }
    printf("Error in update process\n");
    return -1;
}



/*vecotr ver*/
double *malloc_vector(int n)
{
    double *a;
    if ((a=malloc(sizeof(double)*n))==NULL)
    {
        printf("unable to keep memory for vector, sorry\n");
        exit(1);
    }
    return (a-1);/*row number stratsã€€with 1*/
}
void free_vector(double *a)
/*free the memory*/
{
    free(a+1);
}

/*vecotr ver*/
int *malloc_vector_int(int n)
{
    int *a;
    if ((a=malloc(sizeof(double)*n))==NULL)
    {
        printf("unable to keep memory for vector, sorry\n");
        exit(1);
    }
    return (a-1);/*row number stratswith number 1*/
}
void free_vector_int(int *a)
/*free the memory*/
{
    free(a+1);
}

/*matrix ver*/
double **malloc_matrix(int nrow, int ncol)
{
    double **a;
    int i;
    if ((a=malloc(nrow*sizeof(double *)))==NULL)
    {
        printf("unable to keep memory for matrix sorry");
        exit(1);
    }
    a = a-1;
    for (i=1;i<=nrow;i++) a[i]=malloc(ncol*sizeof(double));
    for (i=1;i<=nrow;i++) a[i]=a[i]-1;/* move row direction*/
    
    return a;
}
void free_matrix(double **a, int nrow)
{
    int i;
    for ( i=1; i<=nrow; i++) free((void *)(a[i]+1));
    free((void *)(a+1));}

//probabvility distributions
double Uniform( void )
{
    return genrand_real3();
}
double rand_exp( double lambda )
{
   return -log(Uniform())/lambda;
}
double rand_normal( double mu, double sigma )
{
   double z=sqrt( -2.0*log(Uniform()) ) * sin( 2.0*M_PI*Uniform() );
   return mu + sigma*z;
}



// main function
int main(void)
{
    int *NUM;
    int count=5;
    int i,j;
    double *DEATH;
    char path[256];
    NUM=malloc_vector_int(count);//species number vector
    NUM[1]=2;
    NUM[2]=4;
    NUM[3]=6;
    NUM[4]=8;
    NUM[5]=10;
    DEATH=malloc_vector(count);// mean toxin sensitivity
    DEATH[1]=0.1;
    DEATH[2]=0.2;
    DEATH[3]=0.4;
    DEATH[4]=0.6;
    DEATH[5]=1.0;
    for(i=1;i<=count;i++)
    {
        printf("Death rate %.1f Start\n", DEATH[i]);
        sprintf(path,"./death%.1f", DEATH[i]);
        mkdir(path, 0777);
        chdir(path);
        for (j=1;j<=count;j++)
        {
            //move directory
            printf("=> Number of species is %d\n", NUM[j]);
            sprintf(path,"./Species_number%d",NUM[j]);
            mkdir(path, 0777);
            chdir(path);
            ComDynamics(NUM[j],DEATH[i]);// run community dynamics
            chdir("../");
        }
        chdir("../");
    }
    free_vector_int(NUM);
    free_vector(DEATH);
    return 0;
}
